#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     LIGHT,          sensorLightActive)
#pragma config(Sensor, S3,     LIGHT2,         sensorLightActive)
#pragma config(Motor,  mtr_S1_C1_1,     motor1,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motor2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motor3,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motor4,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
INCLUDES
*/
#include "JoystickDriver.c"

/*
VARS
*/
const int threshold = 3;
int startingValue = 0;
int v = 0;
int tapeValue = 0;
int encoderValue = 0;

/*
FUNCTION DECLARATION
*/
bool doISeeTape();
void findTape();
bool amIonTape(bool both);
void driveAlongTape();
void alignToTape();
void moveFoward();
void moveRotate(int value);
void stopMoving();
void faceTape();

/*
FUNCTIONS
*/
void faceTape() {
	moveFoward();


	wait1Msec(500);
	moveRotate(1);
	nMotorEncoder[motor4] = 0;

	while (encoderValue < 400) {
		encoderValue = nMotorEncoder[motor4];
	}
	stopMoving();
}

void moveFoward() {
	motor[motor1] = -50;
	motor[motor4] = -50;
	motor[motor2] = 50;
	motor[motor3] = 50;
}

void moveRotate(int value) {
	motor[motor1] = 50 * value;
	motor[motor4] = 50 * value;
	motor[motor2] = 50 * value;
	motor[motor3] = 50 * value;
}

void stopMoving() {
	motor[motor1] = 0;
	motor[motor4] = 0;
	motor[motor2] = 0;
	motor[motor3] = 0;
}

void findTape() {
	startingValue = SensorValue[LIGHT];
	motor[motor1] = -30;
	motor[motor4] = -30;

	motor[motor2] = 30;
	motor[motor3] = 30;

	while (!doISeeTape());

	motor[motor1] = 0;
	motor[motor2] = 0;
	motor[motor3] = 0;
	motor[motor4] = 0;
	PlaySound(soundBeepBeep);
	tapeValue = v;
}

bool doISeeTape() {
	v = SensorValue[LIGHT];
	return abs(v - startingValue) >= threshold; //If the new value has changed by 3 compared to the starting value
}

void alignToTape() {
	while (true) {
		int backsense = SensorValue[LIGHT2];
		int frontsense = SensorValue[LIGHT];
		bool moved = false;

		while (abs(tapeValue - backsense) >= threshold + 2) {
			motor[motor1] = 50;
			motor[motor2] = 50;
			motor[motor3] = 0;
			motor[motor4] = 0;
			backsense = SensorValue[LIGHT2];
			moved = true;
		}

		while (abs(tapeValue - frontsense) >= threshold + 2) {
			motor[motor1] = 0;
			motor[motor2] = 0;
			motor[motor3] = 50;
			motor[motor4] = 50;
			frontsense = SensorValue[LIGHT];
			moved = true;
		}

		if (!moved)
			break;
	}
}

void driveAlongTape() {
	while (true) {
		if (amIonTape(true)) {
			motor[motor1] = -30;
			motor[motor4] = -30;

			motor[motor2] = 30;
			motor[motor3] = 30;
		} else if (amIonTape(false)) {
			motor[motor1] = 0;
			motor[motor2] = 0;
			motor[motor3] = 0;
			motor[motor4] = 0;

			wait1Msec(2000);
			alignToTape();
		} else { //Were not on tape anymore..
			break;
		}
	}
}

bool amIonTape(bool both) {
	v = SensorValue[LIGHT];
	int v2 = SensorValue[LIGHT2];
	if (both)
		return abs(v - tapeValue) <= threshold + 1 && abs(v2 - tapeValue) <= threshold + 1;
	else
		return abs(v - tapeValue) <= threshold + 1 || abs(v2 - tapeValue) <= threshold + 1;
}

/*
MAIN
*/
task main()
{
	faceTape(); //Face the tape so we can look for it
	findTape(); //Look for the tape!
	alignToTape(); //Align to the found tape.
	driveAlongTape(); //Drive along the tape.
}
